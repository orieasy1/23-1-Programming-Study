#include <stdio.h>

//---- 비트 연산자 ----
// 1. 10진수가 아닌 2진수의 각 비트별로 연산을 진행
// 2. &(비트 AND 연산): 대응되는 비트가 모두 1이면 1을 반환
// 3. |(비트 OR 연산): 대응되는 비트 중 하나라도 1이면 1을 반환
// 4. ^(비트 XOR 연산): 대응되는 비트가 서로 다르면 1을 반환
// 5. ~(비트 NOT 연산): 비트가 0이면 1, 1이면 0으로 반환
// 6. <<(Left Shift 연산): 비트들을 모두 지정 수 만큼 왼쪽으로 이동
// 7. >>(Right Shift 연산): 비트들을 모두 지정 수 만큼 오른쪽으로 이동
//
/*예시) 2 ,8, 16진수 표현법
10진수   2진수   8진수 16진수
10   0000 1010  12     A
35   0010 0011  43     23
46   0010 1110  56     2E
31   0001 1111  37     1F
62   0011 1110  76     3E
255  1111 1111  377    FF
*/

//음수의 표현 방식: 부호절댓값 방식, 1의 보수, 2의보수
/* 예시)
-59
0011 1011 = 59
1100 0100 => 1의보수
1100 0101 => 2의 보수

-7
0000 0111 = 7
1111 1000 => 1의 보수
1111 1001 => 2의 보수

-100
0110 0100 = 100
1001 1011 => 1의 보수
1001 1100 => 2의 보수*/


int main()
{

/*
printf("비트 AND 연산결과: %d\n", 88 & 76);
// 0101 1000 = 88
// &
// 0100 1100 = 76
//-----------------
// 0100 1000 = 72

printf("비트 OR 연산결과: %d\n", 88 | 76);
// 0101 1000 = 88
// |
// 0100 1100 = 76
//-----------------
// 0101 1100 = 104

print("비트 XOR 연산 결과: %d\n", 88 ^ 76);
// 0101 1000 = 88
// ^
// 0100 1100 = 76
//-----------------
// 0100 1000 = 20

printf("Left Shift 연산 결과: %d\n", 76 << 1);
// 0100 1100 = 76
// << 1
//-----------------
// 1001 1000 =

printf("Right Shift 연산 결과: %d\n", 76 >> 1);
// 0100 1100 = 76
// >> 1
//------------------
// 0010 0110

*/

char num1 = 78, num2 = 37, num3 = 18;
char num4 = 4, num5 = 6;

printf("%d\n", num1 | num3);
printf("%d\n", num5 & num2);
printf("%d\n", num4 ^ num3);
printf("%d\n", (unsigned)~num4);
printf("%d\n", num4 << 3);
printf("%d\n", num3 >> 1);

/*풀이
78 | 18
0100 1110
|
0001 0010
---------
0101 1110 = 94

106 & 37
0110 1010
&
0010 0101
---------
0010 0000 = 32

4 ^ 18
0000 0100
^
0001 0010
----------
0001 0110 = 22

~4
~ 0000 0100
----------
1111 1011 = 251

4 <<3
0000 0100
<<3
----------
0010 0000 = 32

18 >> 1
0001 0010
>>1
-----------
0000 1001 = 9
*/

return 0;
}

