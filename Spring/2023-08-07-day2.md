<h1>Spring DI</h1>

<h3>Spring DI와 IoC 컨테이너</h3>

**Spring DI**<br>
Spring DI란 스프링이 제공하는 의존 관계 주입 기능으로, 객체를 직접 생성하는 것이 아니라 외부에서 생성한 후 주입시켜주는 방식이다.

DI(의존성 주입)를 통해서 모듈 간의 결합도가 낮아지고 유연성이 높아진다.
<br><br>
여기서 dependency(의존)이란 A클래스의 기능을 사용할 때 B클래스의 기능을 이용하는 것을 말한다.
A객체가 B객체에 의존한다라고 말한다.
즉 B객체의 기능을 사용하지 않으면 작동할 수 없다.
B객체의 기능이 변경되면 A객체에 영향을 미친다.
<br><br>
그 중 **첫번째 방식식**은 A객체가 B객체 혹은 C객체와 같은 다른 객체를 new 연산자를 사용하여 직접 생성하는 방식이다.
<br><br>

**직접 객체를 생성하는 Chicken 메이븐 프로젝트**<br>
치킨 메이븐 프로젝트는 A객체가 B객체 혹은 C객체를 new 연산자를 사용하여 직접 생성하는 방식이다.

src/main/java폴더에서 com.spring.di.ex01 패키지 생성
<br><br>
ChickeHouse.java(인터페이스)

```java
package com.spring.di.ex01;

public interface ChickenHouse {

	public void chickenCook();
	
}
```

ChickenOrder.java

```java
package com.spring.di.ex01;

public class ChickenOrder {
	
	 private ChickenHouse chicken;
	 
	 public ChickenOrder() {
		 
		 //chicken = new BBQChicken();
		 chicken = new BHCChicken();
	 }
	 
	 public void chickenOrder() {
		 System.out.println("치킨을 주문합니다.");
		 chicken.chickenCook();
	 }
}
```

<br><br>
ChickenMain.java

```java
package com.spring.di.ex01;

public class ChickenMain {

	public static void main(String[] args) {
		
		ChickenOrder order = new ChickenOrder();
		
		order.chickenOrder();

	}

}
```

<br><br>
BBQChicken.java

```java
package com.spring.di.ex01;

public class BBQChicken implements ChickenHouse {

	@Override
	public void chickenCook() {
		
		System.out.println("BBQ 치킨을 요리합니다.");
		
	}

}
```

<br><br>
BHCChicken.java

```java
package com.spring.di.ex01;

public class BHCChicken implements ChickenHouse {

	@Override
	public void chickenCook() {
		
		System.out.println("BHC 치킨을 요리합니다.");

	}

}
```

**두 번째 방식**은 외부에서, Spring의 경우 IoC 컨테이너에서, 생성된 객체를 setter메소드 혹은 생성자를 통하여 객체를 얻은 뒤 객체를 얻어서 사용하는 방식이다.
이 방식이 Spring DI(Dependency Injection)에서 채택하고 있는 방식이다.

의존하는 객체를 직접 생성하는 대신 의존 객체를 전달받는 방식으로 의존 객체를 변경하는데 있어 유연하다는 장점이 있다.
의존객체가 여러 클래스에서 쓰였을 때 의존 객체를 전달해주는 코드만 변경하면 되기 때문이다.
이 방식을 더 잘 이해하기 위해 IoC는 무엇인지 IoC 컨테이너는 무엇인지 알아보려한다.

**IoC과 IoC 컨테이너**<br>
IoC란 Inversion of Control로 제어 반전을 뜻한다.
제어반전이란 객체의 생성, 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀌었다는 것이다.
내가 아니라 스프링에서 객체를 생성하고 그것을 나는 얻어와서 사용을 하는 것.
<br><br>
컨테이너는 보통 객체의 생명주기를 관리하고 생성된 인스턴스들에게 추가적인 기능을 제공하는 것이다.

스프링 프레임워크도 객체를 생성 관리 책임지고 의존성을 관리해주는 컨테이너가 있는데 그것이 바로 IoC 컨테이너이다.
의존객체를 생성하고 서로 연결(조립, 주입)해주는 것.
인스턴스의 생성부터 소멸까지 생명주기 관리를 IoC 컨테이너가 해주기 때문에 즉 객체관리의 주체가 IoC 컨테이너가 되기 때문에 개발자는 로직에 집중할 수 있다는 장점이 잇다.
<br><br>

**의존 객체를 주입받는 Chicken 메이븐 프로젝트**<br>
ChickenHouse, BBQChicken, BBCChicken은 위와 코드가 동일하다.

```java
package com.spring.di.ex01;

public class ChickenOrder {
	
	 private ChickenHouse chicken;
	 //변수를 인터페이스 타입으로 설정하면 객체들의 타입을 통일시켜주어
	 //개발코드는 해당 인터페이스의 메소드만 호출하면 된다.
	 //즉 객체를 구현하는 코드와 객체를 사용하는 코드를 완전히 분리시켜
	 //객체를 사용하는 코드는 수정할 필요하가 없다. (= 유지보수가 쉬워진다.)
	 
	 public ChickenOrder() {
		 
		 //chicken = new BBQChicken();
		 chicken = new BHCChicken();
	 }

	//이부분이 DI
	public ChickenOrder(ChickenHouse chicken) {
		 this.chicken = chicken;
	 }
	 
	 public void chickenOrder() {
		 System.out.println("치킨을 주문합니다.");
		 chicken.chickenCook();
	 }
}
```

인터페이스형 변수를 선언한 부분에 대한 추가 설명<br>
객체 구현 코드와 객체를 사용하는 코드를 분리하여 개발자가 실제 객체의 구현 내용을 몰라도 사용할 수 있게 한다는 것의 의미는 개발자가 특정 기능을 가진 객체를 사용할 때 해당 객체의 내부 동작 방식이나 구현방식에 대해서 자세히 알 필요가 없다는 것을 나타낸다.
이러한 접근 방식은 객체지향 프로그래밍의 핵심 원칙 중 하나인 인터페이스 분리 원칙이다.

객체의 내부 구현이 변경되더라도 해당 인텊이스를 사용하는 코드에는 영향을 미치지 않는다.
개발자는 인터페이스를 통해 필요한 기능을 사용하면 되기 때문에 코드의 변경범위가 최소화 되어 유지보수가 쉬워지게 된다.
이러한 접근 방식은 객체 지향 프로그래밍에서 캡슐화와 추상화의 개념과 관련이 있다.
<br><br>
ChickenMain.java

```java
package com.spring.di.ex01;

public class ChickenMain {

	public static void main(String[] args) {
		ChickenOrder order2 = new ChickenOrder(new BBQChicken());
		//ChickenOrder order2 = new ChickenOrder(new BHCChicken());
		order2.chickenOrder();
		
		//스프링에서는 의존객체를 생성하고 서로 연결(조립, 주입)해주는 컨테이너가 바로 IoC 컨테이너이다.
	}

}
```

<br><br>

<h3>Spring 컨테이너 종류</h3>
BeanFactory라는 인터페이스(최상위)가 있고 이 인터페이스를 상속받dms ApplicationContext라는 인터페이스가 있다.
이 인테페이스는 BeanFactory에 있는 기능은 물론, MessageSource 인터페이스나 ResourceLoader 인터페이스와 같은 추가적인 기능 또한 구현할 수 있다.
그래서 보통 ApplicationContext를 구현한 클래스로 컨테이너에 접근한다.
java파일을 이용해서 컨테이너를 생성할 수 있고 xml파일을 이용해서 컨테이너를 생성할수도 있다.


xml파일을 이용해서 컨테어너를 만들 때는 src/main/resources 폴더에 생성
Spring Bean Configuration file 클릭하면 된다.

<bean>태그를 사용하여 해당 빈 클래스를 스프링이 관리하는 빈 객체로 생성할 수 있다.
id는 빈의 이름 설정이고, class는 패키지 명을 포함하여 해당 클래스의 전체 이름을 명시한다.
<br><br>
앞서 만든 BBQChicken 클래스와 BHCChicken 클래스를 스프링이 관리하는 빈 객체로 등록을 해주고 싶다면 class의 두 클래스의 정확한 이름을 명시해주면 된다.
BBQChicken 클래스의 정확한 이름은 com.spring.di.ex01.BBQChicken이다.
한마디로 스프링에 관련된 객체 생성이라고 보면 된다.
우리가 객체를 생성할 때 보통 BBQChicken bbq = new ~~; 이렇게 작성하는데 여기서 bbq는 id에 해당한다고 이해할 수 있다.

```xml
<!-- BBQChicken과 BHCChicken으로부터 객체 생성을 하고 싶다면 -->
<bean id ="bbq" class="com.spring.di.ex01.BBQChicken"></bean>
	
<bean id ="bhc" class="com.spring.di.ex01.BHCChicken"></bean>
	
<!-- ChickenOrder 클래스로부터 객체 생성을 하고 싶다면 -->
<bean id ="myOrder" class="com.spring.di.ex01.ChickenOrder"></bean>
```

<br>
이러한 경우들은 기본생성자를 호출하면서 객체생성을 해주는 경우이다.
하지만 만약

```java
public ChickenOrder(ChickenHouse chicken) {
	this.chicken = chicken;
}
```

이한 생성자를 사용하면서 객체 생성을 하고싶다면 어떻게 해야할까?
이 경우는 생성자에 매개변수가 있는 경우이기 때문에 bean 객체를 생성할때도 매개값을 주면서 객체 생성을 해주면 된다.

bean의 여는 태그와 닫는 태그 사이에 <constructor-arg>태그를 사용하면 생성자에 매개값을 줄 수 있다.
위 자바코드를 보면 ChickenHouse 타입의 객체를 받는 것을 확인할 수 있다.
여기서 찾아봤을 때 ChickenHouse 타입의 객체는 bbq와 bhcd이고 이를 작성해주면된다.
또 기본 생성자밖에 없다면 단일태그로 마감처리를 할 수 있다.

최종

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	<!-- BBQChicken과 BHCChicken으로부터 객체 생성을 하고 싶다면 -->
	<bean id ="bbq" class="com.spring.di.ex01.BBQChicken"/>
	
	<bean id ="bhc" class="com.spring.di.ex01.BHCChicken"></bean>
	
	<!-- ChickenOrder 클래스로부터 객체 생성을 하고 싶다면 -->
	<bean id ="myOrder" class="com.spring.di.ex01.ChickenOrder">
		<constructor-arg>
			<ref bean = "bbq" />
		</constructor-arg>
	</bean>
	
</beans>
```

<br><br>
Spring에서 xml파일의 컨테이너 종류에는 GenericXml ApplicationContext 컨테이너가 있다.
IoC컨테이너 객체를 생성을 할 때 스프링 설정 파일에 있는 것들을 읽어와서 객체생성을 해줘야함.
bean 태그로 등록한 객체를 IoC 컨테이너가 관리하는 객체로 생성을 해달라는 것.

저장된 내용을 불러올때는 getBean 메소드를 사용한다.
첫번째는 문자열로 객체 이름을 주고, 두번째로는 객체의 타입을 준다.

ChickenMain.java

```
package com.spring.di.ex01;

import org.springframework.context.support.GenericXmlApplicationContext;

public class ChickenMain {

	public static void main(String[] args) {
		
		//스프링에서는 의존객체를 생성하고 서로 연결(조립, 주입)해주는 컨테이너가 바로 IoC 컨테ㅣ너이다.
		//컨테이너에 의존객체들을 설정하는 설정파일은 xml파일과 자바 파일이 있다.

		GenericXmlApplicationContext context =
				new GenericXmlApplicationContext("classpath:applicationConfig01.xml");
		
		//GenericXmlApplicationContext 클래스는 xml파일에 정의된 설정정보를 읽어와서
		//객체를 생성하고 각각의 객체를 연결한 뒤에 내부적으로 보관한다.
		//빈 객체를 (이름, 객체)의 형태로 보관한다.
		
		//보관하고 있는 내용 불러오기 
		ChickenOrder order3 = context.getBean("myOrder", ChickenOrder.class);
		
		order3.chickenOrder();
		
		context.close();
	}

}
```

<h3>Spring 컨테이너를 활용한 객체 생성 및 조립</h3>

**Student 정보 출력 예시** <br>
01 패키지에서 우클릭 > new > package 하면 이름이 그대로 뜸
거기서 02로 바꿔주기만 하면 빠르게 패키지를 생성할 수 있다.

ctrl + space를 이용하면 생성자를 빠르게 만들 수 있다.
Alt + shift + s를 이용하면 getter setter 메소드를 빠르게 만들 수 있다.

Student 클래스 생성

```
package com.spring.di.ex01;

import org.springframework.context.support.GenericXmlApplicationContext;

public class ChickenMain {

	public static void main(String[] args) {
		
		//ChickenOrder order = new ChickenOrder();
		//order.chickenOrder();
		
		//ChickenOrder order1 = new ChickenOrder(new BBQChicken());
	    //ChickenOrder order2 = new ChickenOrder(new BHCChicken());
		//order2.chickenOrder();
		
		//스프링에서는 의존객체를 생성하고 서로 연결(조립, 주입)해주는 컨테이너가 바로 IoC 컨테ㅣ너이다.
		//컨테이너에 의존객체들을 설정하는 설정파일은 xml파일과 자바 파일이 있다.

		GenericXmlApplicationContext context =
				new GenericXmlApplicationContext("classpath:applicationConfig01.xml");
		
		//GenericXmlApplicationContext 클래스는 xml파일에 정의된 설정정보를 읽어와서
		//객체를 생성하고 각각의 객체를 연결한 뒤에 내부적으로 보관한다.
		//빈 객체를 (이름, 객체)의 형태로 보관한다.
		
		//보관하고 있는 내용 불러오기 
		ChickenOrder order3 = context.getBean("myOrder", ChickenOrder.class);
		
		order3.chickenOrder();
		
		context.close();
	}

}
```

StudentService.java
```
package com.spring.di.ex02;

public class StudentService {

	private Student student;
	
	//setter 메소드
	public void setStudent(Student student) {
		this.student = student;
	}
	
	//학번, 이름, 나이, 전화번호, 동아리를 출력하는 studentProfile 메소드
	public void studentProfile() {
		System.out.println("학번: " + student.getStudentID());
		System.out.println("이름: " + student.getName());
		System.out.println("나이: " + student.getAge());
		System.out.println("전화번호: " + student.getTel());
		System.out.println("동아리: " + student.getCircle());
	}
}
```

setter 메소드를 작성, student 객체를 매개값으로 받아서 필드 초기화를 시켜주고 있음
직접 주입을 받는다 : DI
Student, StudentService bean으로 등록을 시켜줘서 필드 설정하기

applicationConfig02.xml

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	<bean id = "student" class = "com.spring.di.ex02.Student">
		<!-- Student의 속성값을 넣어줘야함 -->
		<property name = "studentID" value = "22102009" />
		<property name = "name" value = "이지원" />
		<property name = "age" value = "21" />
		<property name = "tel" value = "010-1234-5678" />
		<property name ="circle">
			<list>
				<value>개발</value>
				<value>밴드</value>
				<value>사진</value>
				<value>축구</value>
			</list>
		</property>
	</bean>
	
	<bean id = "studentService" class = "com.spring.di.ex02.StudentService">
		<property name = "student" ref="student"/>
	</bean>
</beans>

```

Student 클래스에서 속성들의 접근제한자를 private으로 설정해서 외부에서는 접근할 수 없도록 해놓았는데 property로 값을 넣어줄 수 있을까?
속성에 바로 접근해서 설정해주는 것이 아니기 때문에 가능하다.
그 속성에해당하는 setter 메소드에 접근해서 넣어주는 것이다.

관계도를 살펴보면 student 클래스로 부터 student bean 객체 생성 studentservice로 부터 studentservice bean 객체 생성, student 객체를 studenservice 빈 객체의 프로퍼티 값으로 넣어줌

Beans Graph를 보면 관계도를 확인할 수 잇음

<img width="163" alt="image" src="https://github.com/orieasy1/study-programming-language/assets/129071350/885a2b66-3d42-4314-ab5c-fca8c627e258">

<br>
메인으로 출력하는 페이지인 StudentMian.java

```
package com.spring.di.ex02;

import org.springframework.context.support.GenericXmlApplicationContext;

public class StudentMain {

	public static void main(String[] args) {
		
		GenericXmlApplicationContext context = 
				new GenericXmlApplicationContext("classpath:applicationConfig02.xml");
		
		StudentService service = context.getBean("studentService", StudentService.class);
		
		service.studentProfile();
		
		context.close();
	}

}
```

먼저 스프링 컨테이너를 생성한다.
applicationConfig02.xml파일에 정의된 빈들을 로드하여 컨테이너가 관리하게 된다.
StudentService 클래스 타입으로 컨테이너에서 studentService라는 이름의 빈을 가져오고 이를 이용해서 객체의 메소드롤 호출해서 출력한다.

<br><br>

**Member 정보 출력 예시**

1. Member, MemberMain, MemberService 클래스 생성
2. MemberService에서 속성으로 Member 탕비의 필드를 가지고 있도록 하기
   memberProfile 메소드를 만들어서 회원저오 출력
3. applicationConfig03.xml 스프링 설정 파일을 만든다.
   <bean> 태그롤 Member 클래스와 MemberService 클래스를 스프링이 관리하는 빈 객체로 등록
4. MemberMain 메소드에서 GenericXmlApplicationContext 스프링 컨테이너 생성 후 MemberService 객체를 얻어서 memberProfile 메소드 호출하기

<br>

Member.java

```java
package com.spring.di.ex03;

public class Member {

	private String id;
	private String pw;
	private String name;
	private String age;
	
	public Member() {
		
	}
	
	public String getId() {
		return id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getPw() {
		return pw;
	}
	public void setPw(String pw) {
		this.pw = pw;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getAge() {
		return age;
	}
	public void setAge(String age) {
		this.age = age;
	}
	
	
}
```

MemberService.java

```java
package com.spring.di.ex03;

public class MemberService {

	private Member member;


	public void setMember(Member member) {
		this.member = member;
	}
	
	
	public void memberProfile() {
		System.out.println("학번: " + member.getId());
		System.out.println("전화번호: " + member.getPw());
		System.out.println("이름: " + member.getName());
		System.out.println("나이: " + member.getAge());
		
	}
}
```

applicationConfig03.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	<bean id = "myMember" class = "com.spring.di.ex03.Member">
		<property name = "id" value = "lee" />
		<property name = "pw" value = "1234" />
		<property name = "name" value = "이지원" />
		<property name = "age" value = "21" />
	</bean>
	
	<bean id = "myMemberService" class = "com.spring.di.ex03.MemberService" >
		<property name = "member" >
			<ref bean = "myMember" />
		</property>
	</bean>

</beans>
```

MemberMain.java

```java
package com.spring.di.ex03;

import org.springframework.context.support.GenericXmlApplicationContext;

public class MemberMain {

	public static void main(String[] args) {
		
		GenericXmlApplicationContext context =
				new GenericXmlApplicationContext("classpath:applicationConfig03.xml");
		
		MemberService service = context.getBean("myMemberService", MemberService.class);
		
		service.memberProfile();
		
		context.close(); 

	}

}
```

스프링은 객체들을 기본적으로 싱글톤화 시켜 관리한다.
싱글톤이란 조회할 때마다 클라이언트에게 같은 빈을 반환해준다.

```java
Member member1 = context.getBean("myMember", Member.class);
Member member2 = context.getBean("myMember", Member.class);
		
if (member1 == member2) {
	System.out.println("같은 객체 입니다.");
}else {
	System.out.println("다른 객체 입니다.");
}
```

이렇게 코딩 후 출력하면 같은 객체라는 결과가 나온다.
이를 통해 위 내용을 확인 할 수 있다.
또 member2 객체를 불러와서 아이디 수정을 하여도 member1과 member2는 같은 객체이기 때문에 member1을 출력하면 수정된 결과가 나온다.

```java
System.out.println("아이디: " + member1.getId());
System.out.println("------------------------------");
		
member2.setId("sung");
		
System.out.println("아이디: " + member1.getId());
```

<br><br>

그러나 싱글톤으로만 관리하기 싫고 조회할때마다 다른 객체를 받아내고 싶다면 xml파일로 들어가 sccope = "prototype"이라는 코드를 추가하면 된다.

싱글톤은 조회할 때마다 클라이언트에게 같은 빈을 반환해주는 반면 프로토타입은 조회할 때마다 새로운 인스턴스를 생성해서 반환해준다.

```xml
<bean id = "myMember" class = "com.spring.di.ex03.Member" scope = "prototype">
		<property name = "id" value = "lee" />
		<property name = "pw" value = "1234" />
		<property name = "name" value = "이지원" />
		<property name = "age" value = "21" />
	</bean>
	
	<bean id = "myMemberService" class = "com.spring.di.ex03.MemberService" >
		<property name = "member" >
			<ref bean = "myMember" />
		</property>
	</bean>
```

나중에는 어노테이션으로만 지정을 해서 빈 자동주입을 해준다.
<br><br>
설정파일을 여러 개 둘 수 도 잇을 것이다.
스플일 설정 파일을 여러 개 설정하여 컨테이너를 생성하면 되는데 가변인자를 사용하면 된다.

```java
GenericXmlApplicationContext context =
				new GenericXmlApplicationContext("classpath:applicationConfig03.xml",						"classpath:applicationConfig03_1.xml");
```



