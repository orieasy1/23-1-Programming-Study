
<h3>의존 자동 주입 @Autowired</h3>
2차시에서 했던 것 처럼 setter 메소드와 생성자를 통해서 의존성 주입을 컨테이너에서 직접할 수 있지만 스프링은 자동줍입 기능이 있다.
자동주입 기능을 사용하면 스프링이 알아서 의존객체를 찾아서 주입한다.

**의존 주입 대상에 @Autowired 어노테이션을 사용** 하여 주입할 수 있다.
@Autowired는 필요한 의존 객체의 타입에 해당하는 빈을 찾아 주입한다.
필드, 생성자, setter 메소드 주입이 있다.

<context:annotation-config /> 태그를 이용하여 스프링 컨텡너에 등록된 bean에 대해서 Annotation을 활성화해준다.
@Autowired 및 @Qualifier Annotation을 해석해서 자동 주입을 하도록 한다.

1. @Autowired 필드 주입<br>
필드 주입은 멤버 필드에 @Autowired 어노테이션을 선언하여 주입받는 방법으로 가장 간단한 선언방식이다.
하지만 의존 관계가 보이지 않아 추상적이고, 이로 인해 의존성 관계가 복잡해질 수 있다.
도 의존성 주입 대상 필드에 final 선언이 불가능하다.

2. @Autowired 생성자 주입<br>
생성자 주입은 생성자에게 의존성 주입을 받고자하는 필드에 객체 생성 시 생성자에 주입받는 방법으로, 권고되는 방법이다.
  * 해당하는 bean 객체없이 인스턴스를 만들지 못하도록 강제한다.
  * Spring 4.3이상 부터 생성자가 하나일 때 @Autowired를 사용하지 않아도 된다.
  * 의존성 주입 대상의 필드를 final로 선언하라 수 있다.
순환참조로 주입을 할 경우, 생성자의 주입으로 해결하기 어렵기 때문에 이러한 경우에는 나머지 주입 방법 중에 하나를 사용한다.

3. @Autowire 메소드 주입<br>
메소드 주입은 메소드에 @Autowired 어노테이션을 선언하여 주입 받는 방법이다.
  *  의존성이 선택적으로 필요한 경우에 사용한다.
  *  의존성 주입대상을 선택적으로 나눠서 주입할 수 있게 부담을 덜어준다.
의존성 주입 대상 필드가 final 선언이 불가능하다.
따라서 생성자 주입 방법과 setter 주입 방법을 적절하게 상황에 맞게 분배하여 사용하도록 한다.

<br><br>

<h3>의존 자동 주입 예제: Pet (com.spring.di.ex04)</h3>

**Pet.java**

```java
package com.spring.di.ex04;

public class Pet {

	private String cat;
	private String dog;
	private String fish;
	private String duck;
	
	public Pet(String cat, String dog) {
		this.cat = cat;
		this.dog = dog;
	}

	public String getCat() {
		return cat;
	}

	public void setCat(String cat) {
		this.cat = cat;
	}

	public String getDog() {
		return dog;
	}

	public void setDog(String dog) {
		this.dog = dog;
	}

	public String getFish() {
		return fish;
	}

	public void setFish(String fish) {
		this.fish = fish;
	}

	public String getDuck() {
		return duck;
	}

	public void setDuck(String duck) {
		this.duck = duck;
	}
	
}
```

<br>

**PetProfile.java**

```java
package com.spring.di.ex04;

public class PetProfile {

	private Pet pet;
	
	public PetProfile() {
		
	}
	
	public PetProfile(Pet pet) {
		this.pet = pet;
	}
	
	public void petProfileList() {
		
		System.out.println("## 나의 애완동물 리스트 ##");
		System.out.println("강아지 : " + pet.getDog());
		System.out.println("고양이 : " + pet.getCat());
		System.out.println("물고기 : " + pet.getFish());
		System.out.println("오리 : " + pet.getDuck());
		System.out.println("######################");
	}
}

```

<br>

**applicationConfig04.xml**

1. <bean>태그를 사용하여 Pet 클래스로부터 스프링이 관리하는 빈 객체 만들기
2. PetProfile 클래스로부터 빈 객체 만들기(기본생성자)

```java
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	 
	 <bean id = "myPet" class = "com.spring.di.ex04.Pet">
	 	<!-- constructor-arg 태그 안에 value 태그을 작성 -->
	 	<constructor-arg>
	 		<value>야옹이</value>
	 	</constructor-arg>
	 	
	 	<!-- constructor-arg 태그 안에 value 속성으로 작성-->
	 	<constructor-arg value = "멍멍이" />
	 	
	 	
	 	<!-- property 태그 안에 value 태그를 작성 -->
	 	<property name = "fish">
	 		<value>니모</value>
	 	</property>
	 	<!-- property 태그 안에 value 속성으로 작성  -->
	 	<property name = "duck" value ="꽥꽥이" />
	 	
	 </bean>
	 
	 
	 <bean id ="petPro" class = "com.spring.di.ex04.PetProfile" >
	 	<!-- 여기 아무것도 없음-->
	 </bean>
	 
</beans>
```
위와 같이 그냥 bean객체를 생성했을 때는 기본생성자를 호출해서 객체를 생성했기 때문에 PetProfile 클래스는 어떠한 pet 객체도 넣어지지 않았을 것이다.

그래서 만약에 이렇게

```java
package com.spring.di.ex04;

import org.springframework.context.support.GenericXmlApplicationContext;

public class PetMain {

	public static void main(String[] args) {
		
		//컨테이너 생성
		GenericXmlApplicationContext context = new GenericXmlApplicationContext("classpath:applicationConfig04.xml");
		
		PetProfile petPro = context.getBean("petPro", PetProfile.class);
		
		petPro.petProfileList();
		
		context.close();
	}

}
```
이렇게 코드를 작성하고 실행시킬 경우에는 null exception이 발생하게 된다. 
petProfileList를 호출하는데 있어서 pet 필드가 null값이고 어떠한 객체도 참조하고 있지 않다는 것.
객체를 참조시키기 위해서는 생성자에서 새 객체를 넣어줘야할 것.


그래서 applicationConfig04.xml을 다음과 같이 변경해준다면 myPet에 넣은 값을 PetMain 클래스에서 실행시켰을 때 그 값이 출력되는 것을 확인할 수 있을 것이다.

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	 <bean id = "myPet" class = "com.spring.di.ex04.Pet">
	 	<!-- constructor-arg 태그 안에 value 태그을 작성 -->
	 	<constructor-arg>
	 		<value>야옹이</value>
	 	</constructor-arg>
	 	
	 	<!-- constructor-arg 태그 안에 value 속성으로 작성-->
	 	<constructor-arg value = "멍멍이" />
	 	
	 	
	 	<!-- property 태그 안에 value 태그를 작성 -->
	 	<property name = "fish">
	 		<value>니모</value>
	 	</property>
	 	<!-- property 태그 안에 value 속성으로 작성  -->
	 	<property name = "duck" value ="꽥꽥이" />
	 	
	 </bean>
	 
	 
	 <bean id ="petPro" class = "com.spring.di.ex04.PetProfile" >
	 	<constructor-arg ref = "myPet"/>
	 </bean>
	 
</beans>
```

그런데 참조하는 부분이 myPet이 아니라 다른 것으로 매번 바뀐다면 설정파일에서 건들일 수 도 있겠지만 더 간단한 방법이 있다.
PetProfile 클래스로 와
