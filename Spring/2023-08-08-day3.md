
<h3>의존 자동 주입 @Autowired</h3>
2차시에서 했던 것 처럼 setter 메소드와 생성자를 통해서 의존성 주입을 컨테이너에서 직접할 수 있지만 스프링은 자동줍입 기능이 있다.
자동주입 기능을 사용하면 스프링이 알아서 의존객체를 찾아서 주입한다.

**의존 주입 대상에 @Autowired 어노테이션을 사용** 하여 주입할 수 있다.
@Autowired는 필요한 의존 객체의 타입에 해당하는 빈을 찾아 주입한다.
필드, 생성자, setter 메소드 주입이 있다.

<context:annotation-config /> 태그를 이용하여 스프링 컨텡너에 등록된 bean에 대해서 Annotation을 활성화해준다.
@Autowired 및 @Qualifier Annotation을 해석해서 자동 주입을 하도록 한다.

1. @Autowired 필드 주입<br>
필드 주입은 멤버 필드에 @Autowired 어노테이션을 선언하여 주입받는 방법으로 가장 간단한 선언방식이다.
하지만 의존 관계가 보이지 않아 추상적이고, 이로 인해 의존성 관계가 복잡해질 수 있다.
도 의존성 주입 대상 필드에 final 선언이 불가능하다.

2. @Autowired 생성자 주입<br>
생성자 주입은 생성자에게 의존성 주입을 받고자하는 필드에 객체 생성 시 생성자에 주입받는 방법으로, 권고되는 방법이다.
  * 해당하는 bean 객체없이 인스턴스를 만들지 못하도록 강제한다.
  * Spring 4.3이상 부터 생성자가 하나일 때 @Autowired를 사용하지 않아도 된다.
  * 의존성 주입 대상의 필드를 final로 선언하라 수 있다.
순환참조로 주입을 할 경우, 생성자의 주입으로 해결하기 어렵기 때문에 이러한 경우에는 나머지 주입 방법 중에 하나를 사용한다.

3. @Autowire 메소드 주입<br>
메소드 주입은 메소드에 @Autowired 어노테이션을 선언하여 주입 받는 방법이다.
  *  의존성이 선택적으로 필요한 경우에 사용한다.
  *  의존성 주입대상을 선택적으로 나눠서 주입할 수 있게 부담을 덜어준다.
의존성 주입 대상 필드가 final 선언이 불가능하다.
따라서 생성자 주입 방법과 setter 주입 방법을 적절하게 상황에 맞게 분배하여 사용하도록 한다.

<br><br>

<h3>의존 자동 주입 예제: Pet (com.spring.di.ex04) - xml파일 사용</h3>

**Pet.java**

```java
package com.spring.di.ex04;

public class Pet {

	private String cat;
	private String dog;
	private String fish;
	private String duck;
	
	public Pet(String cat, String dog) {
		this.cat = cat;
		this.dog = dog;
	}

	public String getCat() {
		return cat;
	}

	public void setCat(String cat) {
		this.cat = cat;
	}

	public String getDog() {
		return dog;
	}

	public void setDog(String dog) {
		this.dog = dog;
	}

	public String getFish() {
		return fish;
	}

	public void setFish(String fish) {
		this.fish = fish;
	}

	public String getDuck() {
		return duck;
	}

	public void setDuck(String duck) {
		this.duck = duck;
	}
	
}
```

<br>

**PetProfile.java**

```java
package com.spring.di.ex04;

public class PetProfile {

	private Pet pet;
	
	public PetProfile() {
		
	}
	
	public PetProfile(Pet pet) {
		this.pet = pet;
	}
	
	public void petProfileList() {
		
		System.out.println("## 나의 애완동물 리스트 ##");
		System.out.println("강아지 : " + pet.getDog());
		System.out.println("고양이 : " + pet.getCat());
		System.out.println("물고기 : " + pet.getFish());
		System.out.println("오리 : " + pet.getDuck());
		System.out.println("######################");
	}
}

```

<br>

**applicationConfig04.xml**

1. <bean>태그를 사용하여 Pet 클래스로부터 스프링이 관리하는 빈 객체 만들기
2. PetProfile 클래스로부터 빈 객체 만들기(기본생성자)

```java
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
	 
	 <bean id = "myPet" class = "com.spring.di.ex04.Pet">
	 	<!-- constructor-arg 태그 안에 value 태그을 작성 -->
	 	<constructor-arg>
	 		<value>야옹이</value>
	 	</constructor-arg>
	 	
	 	<!-- constructor-arg 태그 안에 value 속성으로 작성-->
	 	<constructor-arg value = "멍멍이" />
	 	
	 	
	 	<!-- property 태그 안에 value 태그를 작성 -->
	 	<property name = "fish">
	 		<value>니모</value>
	 	</property>
	 	<!-- property 태그 안에 value 속성으로 작성  -->
	 	<property name = "duck" value ="꽥꽥이" />
	 	
	 </bean>
	 
	 
	 <bean id ="petPro" class = "com.spring.di.ex04.PetProfile" >
	 	<!-- 여기 아무것도 없음-->
	 </bean>
	 
</beans>
```
위와 같이 그냥 bean객체를 생성했을 때는 기본생성자를 호출해서 객체를 생성했기 때문에 PetProfile 클래스는 어떠한 pet 객체도 넣어지지 않았을 것이다.

그래서 만약에 이렇게 **PetMain.java**를 작성하고 실행시킬 경우에는 null exception이 발생하게 된다. 

```java
package com.spring.di.ex04;

import org.springframework.context.support.GenericXmlApplicationContext;

public class PetMain {

	public static void main(String[] args) {
		
		//컨테이너 생성
		GenericXmlApplicationContext context = new GenericXmlApplicationContext("classpath:applicationConfig04.xml");
		
		PetProfile petPro = context.getBean("petPro", PetProfile.class);
		
		petPro.petProfileList();
		
		context.close();
	}

}
```

petProfileList를 호출하는데 있어서 pet 필드가 null값이고 어떠한 객체도 참조하고 있지 않다는 것.
객체를 참조시키기 위해서는 생성자에서 새 객체를 넣어줘야할 것.


그래서 applicationConfig04.xml을 다음과 같이 변경해준다면 myPet에 넣은 값을 PetMain 클래스에서 실행시켰을 때 그 값이 출력되는 것을 확인할 수 있을 것이다.

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

	 <bean id = "myPet" class = "com.spring.di.ex04.Pet">
	 	<!-- constructor-arg 태그 안에 value 태그을 작성 -->
	 	<constructor-arg>
	 		<value>야옹이</value>
	 	</constructor-arg>
	 	
	 	<!-- constructor-arg 태그 안에 value 속성으로 작성-->
	 	<constructor-arg value = "멍멍이" />
	 	
	 	
	 	<!-- property 태그 안에 value 태그를 작성 -->
	 	<property name = "fish">
	 		<value>니모</value>
	 	</property>
	 	<!-- property 태그 안에 value 속성으로 작성  -->
	 	<property name = "duck" value ="꽥꽥이" />
	 	
	 </bean>
	 
	 
	 <bean id ="petPro" class = "com.spring.di.ex04.PetProfile" >
	 	<constructor-arg ref = "myPet"/>
	 </bean>
	 
</beans>
```

그런데 참조하는 부분이 myPet이 아니라 다른 것으로 바뀐다면 설정파일에서 건들일 수 도 있겠지만 더 간단한 방법이 있다.
PetProfile 클래스로 와서 필드위에다 @Autowired 어노테이션을 작성해주면 된다.
bean 태그 사이에 <constructor-arg ref = "myPet"/>를 작성해줄 필요도 없다.

**PetProfile.java**

```java
package com.spring.di.ex04;

import org.springframework.beans.factory.annotation.Autowired;

//@Autowired : 객체를 자동 주입할 때 사용하는 어노테이션
// 의존 객체의 타입이 해당하는 Bean을 찾아 주입한다.
// 필드, 생성자, 메소드 주입 방식이 있다.

public class PetProfile {

	@Autowired(required = false) // : 필드주입
	//false로 지정하면 빈 객체가 존재하지 않더라도 예외 발생 X
	private Pet pet;
	
	//기본생성자
	public PetProfile() {
		
	}
	
	//@Autowired  : 생성자 주입
	public PetProfile(Pet pet) {
		this.pet = pet;
	}
	
	//setter 메소드
	//@Autowired : 메소드 주입
	public void setPet(Pet pet) {
		this.pet = pet;
	}
	public void petProfileList() {
		if(pet == null) {
			System.out.println("나의 애완동물이 없습니다.");
			return;
		}
		
		System.out.println("## 나의 애완동물 리스트 ##");
		System.out.println("강아지 : " + pet.getDog());
		System.out.println("고양이 : " + pet.getCat());
		System.out.println("물고기 : " + pet.getFish());
		System.out.println("오리 : " + pet.getDuck());
		System.out.println("######################");
	}
}

```

그대신 설정파일에서 스프링 컨테이너에 등록 된 빈에 대해서 autowired 어노테이션을 활성화시켜주는 태그를 작성해야한다.

태그 사용을 위해서는 namespaces로 활성화 시켜줘야함. context에 체크 표시하면 됨

<img width="904" alt="image" src="https://github.com/orieasy1/study-programming-language/assets/129071350/546dc84b-ea23-4dfa-8e29-4cfcbf496984">

xml파일 위쪽을 살펴보면 콘텍스트가 활성화된 것을 확인할 수 있음

생성자 태그를 대체하는 네임스페이스는 c이고 property를 대체하는 네임스페이스는 p이더.
두개 체크해줄 것
이러면 굳이 태그를 더 작성해주지 않아도 bean 단일태그로 해결할 수 있다.
이를 통해 첫번째 빈 전체 내용을 한줄로 정리할 수 있다.

```xml
	<bean id = "myPet" class = "com.spring.di.ex04.Pet">
		<!-- constructor-arg 태그 안에 value 태그을 작성 -->
		<constructor-arg>
	 		<value>야옹이</value>
	 	</constructor-arg>
	 	
	 	<!-- constructor-arg 태그 안에 value 속성으로 작성-->
	 	<constructor-arg value = "멍멍이" />
	 	
	 	
	 	<!-- property 태그 안에 value 태그를 작성 -->
	 	<property name = "fish">
	 		<value>니모</value>
	 	</property>
	 	<!-- property 태그 안에 value 속성으로 작성  -->
	 	<property name = "duck" value ="꽥꽥이" />
	 	
	</bean>
	
	<bean id = "myPet2" class = "com.spring.di.ex04.Pet" c:cat="야옹이2" c:dog="멍멍이2" p:fish ="니모2" p:duck="꽥꽥이2" />
```

<br>

**applicationConfig04.xml**를 이렇게 간단하게 적을 수 있다.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:c="http://www.springframework.org/schema/c"
	xmlns:p="http://www.springframework.org/schema/p"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd">

	<bean id = "myPet2" class = "com.spring.di.ex04.Pet" c:cat="야옹이2" c:dog="멍멍이2" p:fish ="니모2" p:duck="꽥꽥이2" /> 
	 
	<bean id ="petPro" class = "com.spring.di.ex04.PetProfile" />
	 
	 <!-- 
	 	스프링 컨텍스트에 생성되어 저장된 빅 객체들에 대해
	 	@Autowired 와 @Qualifier 어노테이션을 인식할 수 있도록 하는 스캔 명령
	  -->
	  
	  <context:annotation-config />
	  
</beans>
```

autowired는 의존 객체의 타입에 해당하는 빈을 찾아 주입하는 어노테이션이다.
myPet과 myPet2를 함께 작성하게 되면 어느 빈을 찾아 주입해야하는지 컴퓨터는 알 수 없다.
그래서 이 둘을 함께 작성하면 오류가 발생한다.

둘 중 하나만 작성하거나 지정을 해줄 수 있다.
지정하는 방법은 Qualifier 어노테이션을 사용하는 것 이 다.
@Qualifier("빈 아이")을 @Autowired 어노테이션 위에 작성해주면 된다.

만약 필드 주입이라면

```xml
@Qualifier("myPet2")
@Autowired(required = false)
private Pet pet;
```

이렇게 작성해줄 수 있을 것이다.


스프링 컨테이너에는 AnnotationConfig ApplicationContext와 GenericXml ApplicationContext 이렇게 두 가지 종류가 있는데 지금까지 설정파일을 xml파일로 만들었다.
이제 java 파일로 설정파일을 만드는 방법을 알아보려고 한다.

<br><br>

<h3>Pet 프로젝트 - 자바파일을 설정파일로 쓰는 경우</h3>

자바파일을 설정파일로 쓰고 싶다면 스프링 IoC 컨테이너가 해당 클래스파일을 스프링 설정파일로 사용할 수 있도록 클래스위에 @Configuration 어노테이션을 붙여준다.

이 설정파일에서 스프링이 관리하는 빈 객체로 등록하기 위해서는 이 하나하나를 메소드로 만들어주어야한다.
메소드의 반환 타입을 객체로 해줄 것, 메소드 안에서는 객체를 직접 생성해줄 것
그리고 setter 메소드로도 정보를 입력해줄 수 있음

리턴 뉴 생성자로 객체를 생성해주고 그 안에 매개값을 넣어서 줄 수도 있음
return new PetProfile(myPet());를 풀어서 작성하면

Pet pet = myPet();<br>
PetProfile petPro = new PetProfile(pet);<br>
return petPro;<br>
이 된다.
코드의 간결성을 위해  한줄로 작성할 수 있는 코드를 위와 같이 풀어서 작성하는 것을 권장하지 않는다.


<h3>Member Project </h3>

**Member.java**

```java
package com.spring.di.ex05;

public class Member {

	private String id;
	private String pw;
	private String name;
	private int age;
	
	public Member(String id, String pw) {
		this.id = id;
		this.pw = pw;
	}

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getPw() {
		return pw;
	}

	public void setPw(String pw) {
		this.pw = pw;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
	
}
```

**MemberService.java**

```java
package com.spring.di.ex05;

public class MemberService {

	private Member member;
	
	public MemberService(Member member) {
		this.member = member;
	}
	
	//1. 회원의 정보를 출력해주는 memberProfile 메소드 만들기
	public void memberProfile() {
		System.out.println("---------------------");
		System.out.println("아이디: " + member.getId());
		System.out.println("비밀번호: " + member.getPw());
		System.out.println("이 름: " + member.getName());
		System.out.println("나 이: " + member.getAge());
		System.out.println("----------------------");
	}
	
	//2. 아이디와 비밀번호를 체크하여 회원이 있는 경우
	//	아이디와 비밀번호가 null값이 아닌 경우
	//	로그인 되었습니다를 출력해주는 loginInfo 메소드 만들기
	public void loginInfo() {
		if(member == null) {
			System.out.println("회원이 등록되어있지 않습니다.");
			return;
		}
		
		if(member.getId() != null && member.getPw() != null) {
			System.out.println("로그인 되었습니다.");
			System.out.println("로그인된 아이디: " + member.getId());
			System.out.println("로그인된 비밀번호: " + member.getPw());
			
		}else {
			System.out.println("로그인 실패입니다.");
		}
	}
}
```

**ApplicationConfig02.java***

```java
package com.spring.di.ex05;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ApplicationConfig02 {
	//Member와 MemberService 클래스 빈 객체로 등록
	@Bean
	public Member myMember() {
		Member member = new Member("hong", "1234");
		
		member.setName("홍길동");
		member.setAge(20);
		
		return member;
	}
	
	@Bean(name = "service")
	public MemberService service() {
		
		return new MemberService(myMember());
	}
}
```

**MemberMain.java**

```java
package com.spring.di.ex05;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class MemberMain {

	public static void main(String[] args) {
		
		//ApplicationConfig02 클래스에서 Member와 MemberService 클래스를
		//스프링이 관리하는 빈 객체로 등록한 후
		//main메소드에서 스프링 컨테이너 생성 후 
		//MemberService 객체를 얻어와 loginInfo 메소드와 memberProfile 메소드 호출하기
		
		AnnotationConfigApplicationContext context = 
				new AnnotationConfigApplicationContext(ApplicationConfig02.class);

		MemberService service = context.getBean("service", MemberService.class);
		
		service.loginInfo();
		service.memberProfile();
		
		context.close();
		
	}

}

```

